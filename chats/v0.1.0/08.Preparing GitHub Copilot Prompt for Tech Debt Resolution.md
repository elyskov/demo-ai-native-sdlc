User: Act as an experienced web full-stack software engineer and prompt engineer in software development, and help prepare a prompt for GitHub Copilot in the context of the current project.

This prompt should give the Copilot a clear task to implement the first criterion ("Tech debt is identified, prioritized, and the most critical debt is resolved") from the task #8 "Technical debt and deployment".

An independent code reviewer reviewed the codebase (primarily the backend) and made a number of recommendations:

> ## 1. Dependency Injection and Abstraction
> 
> To align with production best practices and ensure loose coupling, it is recommended to use unique symbols for provider tokens. Instead of injecting concrete classes, use the `@Inject()` decorator to inject services via their interfaces.
> 
> **Recommended Pattern:**
> ```
> constructor(
>   @Inject(X_SERVICE_TOKEN)
>   private readonly xService: IXService,
> ) {}
> ```
> ---
> 
> ## 2. Lifecycle Hooks Selection
> 
> The current implementation utilizes `onModuleInit` for service initialization. However, for logic that requires the entire application to be fully booted (e.g., establishing connections to external databases, file systems, or Key Vaults), it is more appropriate to use the `onApplicationBootstrap` hook.
> 
> This ensures that the logic executes only when the application is ready to handle requests.
> 
> ---
> 
> ## 3. Type Architecture and File Organization
> 
> To improve maintainability and readability, please consider the following restructuring:
> 
> - **Decoupling**: Move auxiliary types (DTOs, temporary structures, parameters, and response wrappers) to a dedicated `types/` directory.
> - **File Separation**: Each model or complex type should reside in its own file.
> - **Enums / Unions**: Keep Enums or Union types in the same file as the model only if they are strictly coupled to that specific model's properties.
> 
> ---
> 
> ## 4. Service Granularity and Naming Conventions
> 
> - **Service Sizing**: Review the current service logic to ensure it adheres to the Single Responsibility Principle. Services should be neither overly monolithic nor excessively fragmented.
> - **Naming**: Reserve the `Service` suffix for classes that are registered as providers and exported within modules. Internal utility classes or logic handlers that are not part of the NestJS provider system should be named according to their specific functional role (e.g., `Helper`, `Processor`, `Handler`).

Please do the following:
- Review the project codebase and confirm relevance of proposed improvements above.
- Identify other possible technical debt.
- Prioritize all identified cases (including relevant recommendations from the reviewer) and suggest most critical cases which should be fixed.
- Present each suggested case with necessary explanations and request my confirmation to include it to the final list for fixing.

As soon as all tech debt is discussed, please prepare a prompt for Copilot, which should do the following:
- generate a new issue (draft) for all identified most critical tech debt cases (title, description acceptance criteria - presented as checkpoints).
- show this draft and get approval.
- create this issue in GitHub and add it as a sub-task to issue Generate CSV files for NetBox #8.
- create a new feature branch (from main) for this issue implementation.
- implement necessary code changes.
- check application health.
suggest test cases to confirm that context operations work as expected.

Please generate a corresponding prompt in Markdown format. Do not use "```" combination, use other ways to represent code fragments.

GitHub Copilot: I’m going to (1) scan the backend for the reviewer’s themes (DI tokens/interfaces, lifecycle hooks, type organization, service sizing/naming), (2) note any additional tech-debt hotspots, then (3) come back with a prioritized list where you can approve/reject each item before I craft the final “Copilot prompt” to implement the most critical ones end-to-end.

Created 4 todos

Next I’ll quickly grep/read the backend for `onModuleInit`, direct class injection patterns, and module provider registrations to assess how relevant the reviewer recommendations are.

Searched for regex `onModuleInit|OnModuleInit|onApplicationBootstrap|OnApplicationBootstrap` (`**/services/backend/src/**/*.ts`), 9 results

Searched for regex `constructor\s*\(|@Inject\(|provide:\s*|useClass:\s*|useValue:\s*|useFactory:\s*` (`**/services/backend/src/**/*.ts`), 18 results

Searched for regex `export\s+interface\s+I[A-Z]|interface\s+I[A-Z]|symbol\s*=\s*Symbol\(` (`**/services/backend/src/**/*.ts`), no results

Searched for regex `class\s+\w+Service\b|@Injectable\(` (`**/services/backend/src/**/*.ts`), 23 results

Searched for regex `dto|models|types` (`**/services/backend/src/**`), 200 results

Found the lifecycle-hook usage and current DI pattern hotspots; next I’ll open the key services/modules to judge impact and spot additional debt (type layout, SRP, naming, config loading).

Read [](file:///home/<user>/Projects/demo-ai-native-sdlc/services/backend/src/netbox-config/netbox-config.service.ts)

Read [](file:///home/<user>/Projects/demo-ai-native-sdlc/services/backend/src/diagrams/diagrams.service.ts#1-1), lines 1 to 260

Read [](file:///home/<user>/Projects/demo-ai-native-sdlc/services/backend/src/csv/csv.module.ts)

Read [](file:///home/<user>/Projects/demo-ai-native-sdlc/services/backend/src/csv/csv.service.ts)

Read [](file:///home/<user>/Projects/demo-ai-native-sdlc/services/backend/src/diagrams/commands/diagrams-commands.service.ts#1-1), lines 1 to 420

Read [](file:///home/<user>/Projects/demo-ai-native-sdlc/services/backend/src/diagrams/commands/diagrams-commands.service.ts#420-420), lines 420 to 424

Starting: *Identify additional technical debt* (2/4)

Read [](file:///home/<user>/Projects/demo-ai-native-sdlc/services/backend/src/diagrams/commands/diagram-domain.store.ts)

Read [](file:///home/<user>/Projects/demo-ai-native-sdlc/services/backend/src/netbox-config/netbox-model.service.ts)

Read [](file:///home/<user>/Projects/demo-ai-native-sdlc/services/backend/src/netbox-config/netbox-config.module.ts)

Read [](file:///home/<user>/Projects/demo-ai-native-sdlc/services/backend/src/shared/fs-utils.ts)

Read [](file:///home/<user>/Projects/demo-ai-native-sdlc/services/backend/src/csv/csv.generator.ts)

Read [](file:///home/<user>/Projects/demo-ai-native-sdlc/services/backend/src/csv/models/csv.models.ts)

Read [](file:///home/<user>/Projects/demo-ai-native-sdlc/services/backend/src/netbox-config/netbox-config.models.ts)

Read [](file:///home/<user>/Projects/demo-ai-native-sdlc/services/backend/src/csv/netbox-csv.generator.ts)

Read [](file:///home/<user>/Projects/demo-ai-native-sdlc/services/backend/src/csv/mock-csv.generator.ts)

Read [](file:///home/<user>/Projects/demo-ai-native-sdlc/services/backend/src/shared/http-exception.filter.ts)

Read [](file:///home/<user>/Projects/demo-ai-native-sdlc/services/backend/src/main.ts)

Read [](file:///home/<user>/Projects/demo-ai-native-sdlc/services/backend/src/app.module.ts)

Read [](file:///home/<user>/Projects/demo-ai-native-sdlc/services/backend/src/diagrams/diagrams.module.ts)

Read [](file:///home/<user>/Projects/demo-ai-native-sdlc/services/backend/src/diagrams/diagrams.controller.ts)

Read [](file:///home/<user>/Projects/demo-ai-native-sdlc/services/backend/test/netbox-csv-generator.test.ts)

Starting: *Prioritize and propose fix list* (3/4)

**Relevance check (reviewer recommendations)**  
- **DI tokens + interface-style injection**: Relevant. Most controllers/services inject concrete classes directly (Nest default), and the one place that uses a provider token uses a **string** token (collision-prone): csv.generator.ts + csv.module.ts. Moving to unique `Symbol()` tokens (and injecting via token) is a solid production-hardening step.  
- **Lifecycle hook selection**: Partially relevant. You already use `onApplicationBootstrap` in netbox-model-analysis.service.ts. Config loading in netbox-config.service.ts currently uses `onModuleInit`; switching hooks isn’t automatically “better” here unless we also guarantee ordering and error semantics.  
- **Types/file organization**: Relevant but potentially large. Types are split across `dto/` and `models/`, but there are also extra types embedded in services (e.g., diagrams.service.ts) and multi-model “bundle” files (e.g., csv.models.ts).  
- **Service granularity/naming**: Some relevance. A couple services are “do-a-lot” (e.g., diagrams-commands.service.ts), but this is less urgent than correctness/production-safety issues.

## Proposed tech-debt cases (prioritized) — please approve/reject each
### P0 (most critical to fix)
1) **Make sample-data seeding opt-in (avoid production side effects)**  
   - Where: diagrams.service.ts seeds sample diagrams automatically when storage is empty.  
   - Why critical: first run in prod silently creates data and writes to persistent volume; can confuse users/tests and violates “no surprises” production behavior.  
   - Fix idea: gate seeding behind `SEED_SAMPLE_DIAGRAMS=true` or `NODE_ENV !== 'production'`, and log when skipped.  
   - Include in “critical fix” issue? **(Y/N)**

2) **Harden provider tokens (replace string tokens with unique symbols; consistent DI abstraction boundary)**  
   - Where: `CSV_DATASET_GENERATOR` is a string token in csv.generator.ts.  
   - Why critical: string tokens can collide across modules/libraries; symbols are safer and align with reviewer guidance.  
   - Fix idea: export `export const CSV_DATASET_GENERATOR = Symbol('CSV_DATASET_GENERATOR')` and update module + injections accordingly. Optionally centralize tokens in a `tokens.ts`.  
   - Include? **(Y/N)**

### P1 (high value, but slightly broader)
3) **Improve NetBox config loading error semantics + validation**  
   - Where: netbox-config.service.ts throws generic `Error` on invalid YAML sections.  
   - Why: on failure you get a 500/fatal without clear operator guidance; also YAML parse returns `unknown` and is only lightly validated.  
   - Fix idea: throw a Nest exception with a clear message, validate required keys more explicitly, and include file paths in logs (without leaking secrets).  
   - Include? **(Y/N)**

4) **Domain state validation on load (prevent corrupt/invalid parent refs from propagating)**  
   - Where: diagram-domain.store.ts trusts `parent` shape and uses `any`-ish parsing.  
   - Why: malformed `.domain.json` can cause odd runtime failures later; better to validate/normalize `parent` to the union type.  
   - Fix idea: validate `parent` is either `{root: 'definitions'|'infrastructure'}` or `{entity: string, id: string}`; otherwise reject as corrupt.  
   - Include? **(Y/N)**

### P2 (nice-to-have / defer unless you want a cleanup pass)
5) **Type/file organization cleanup (incremental, not sweeping)**  
   - Where: types embedded in services and multi-class model files (examples above).  
   - Why: maintainability/readability; aligns with reviewer advice, but can be a churn-heavy refactor.  
   - Fix idea: only move the most reused types first (e.g., diagram entities/metadata) into existing `models/` and avoid “big bang” directory reshuffles.  
   - Include? **(Y/N)**

6) **Command service decomposition (SRP)**
   - Where: diagrams-commands.service.ts.  
   - Why: long file, many responsibilities; but it’s currently readable and tested indirectly.  
   - Fix idea: extract internal handlers (e.g., `ApplyCreateHandler`) without changing API surface.  
   - Include? **(Y/N)**

## Other technical debt I noticed (for awareness)
- Write safety is “single-process” only (in-memory lock). Scaling backend replicas would risk file-write races; likely out-of-scope for MVP but worth tracking.

If you reply with a quick list like: `1:Y 2:Y 3:N 4:Y 5:N 6:N`, I’ll then generate the final Copilot prompt (Markdown, no triple-backticks) that: drafts the GitHub issue, gets approval, creates it + links it under “Generate CSV files for NetBox #8”, creates a feature branch, implements changes, runs health checks, and proposes concrete test cases for diagram command/context operations.

User: 1:Y 2:Y 3:Y 4:Y 5:N 6:N,

GitHub Copilot: I’ll quickly check the existing health endpoints so the Copilot prompt can validate “application health” with the right URLs/commands.

Read [](file:///home/<user>/Projects/demo-ai-native-sdlc/services/backend/src/health/health.controller.ts)

Read [](file:///home/<user>/Projects/demo-ai-native-sdlc/services/backend/src/health/health-api.controller.ts)

Read [](file:///home/<user>/Projects/demo-ai-native-sdlc/docker-compose.yml)

Completed: *Prioritize and propose fix list* (3/4)

Here’s the Markdown prompt you can paste into GitHub Copilot (Chat) in this repo to implement the agreed “most critical tech debt” items for issue #8.

---

# Copilot Task Prompt — Tech Debt (Issue #8 / Criterion 1)

You are GitHub Copilot acting as a senior full‑stack engineer. Your goal is to satisfy criterion 1 for “Technical debt and deployment” (issue #8): **Tech debt is identified, prioritized, and the most critical debt is resolved**.

Scope is **backend-first** (NestJS). Follow repo governance: MVP changes only, keep diffs focused, keep behavior stable unless explicitly changed, and update README only if user-visible behavior changes.

## What to fix (approved critical list)

Implement the following tech-debt fixes, in this priority order, without doing broad refactors:

### P0 — Prevent production side effects
1) Make sample diagram seeding opt‑in (no implicit writes on first run)
- Current behavior: on startup, if diagrams storage is empty, sample diagrams are created automatically in diagrams.service.ts.
- Target behavior:
  - Default in production: do NOT seed sample diagrams.
  - Seeding should happen only if explicitly enabled, e.g. env var `SEED_SAMPLE_DIAGRAMS=true` (exact name ok to choose, but document it).
  - Log clearly whether seeding is enabled/disabled and why.
  - Keep local/dev experience reasonable (recommend: default to off; allow enabling via env var).

### P0 — Safer DI provider tokens
2) Replace string DI tokens with unique symbols for `CSV_DATASET_GENERATOR`
- Current token is a string in csv.generator.ts.
- Target behavior:
  - Use a unique `Symbol()` token (or `Symbol.for` if you prefer global registry—explain the choice in PR/issue description).
  - Update all providers and injections accordingly:
    - csv.module.ts
    - csv.service.ts
    - any other references.

### P1 — Clearer config loading failures + validation
3) Improve NetBox config load/validation and error semantics
- Current implementation: netbox-config.service.ts loads YAML in `onModuleInit()` and throws generic `Error` on invalid structure.
- Target behavior:
  - Provide clearer, actionable errors (include which required section is missing and which file path failed).
  - Validate the presence of required sections at minimum:
    - model: `entities`
    - mapping: `entities`, `roots`
    - styles: optional but should be validated if present (don’t crash if styles are missing unless required by runtime)
  - Use Nest-friendly exception types when appropriate (but note: this happens at bootstrap; crashing fast is OK, crashing cryptically is not).
  - Keep I/O parallelism (Promise.all) as is.

### P1 — Validate domain state on load
4) Validate/normalize `parent` in domain state loading to prevent corrupt `.domain.json` from causing downstream failures
- Current: diagram-domain.store.ts accepts `parent` as-is.
- Target behavior:
  - When parsing objects from disk, validate that `parent` is exactly one of:
    - `{ root: 'definitions' | 'infrastructure' }`
    - `{ entity: string; id: string }` (both non-empty)
  - If invalid, treat as corrupt state and fail with a clear error (consistent with existing “Corrupt diagram domain state” behavior).
  - Keep backward compatibility where possible; only reject truly invalid shapes.

Non-goals:
- Do NOT do broad “types/ directory” reorgs.
- Do NOT decompose large services unless necessary for the above tasks.
- Do NOT change API endpoints or payload schemas unless required.

---

## Step A — Create a GitHub issue draft (and get approval)

Create a new issue draft with:

### Title (suggestion)
“techdebt(backend): opt-in seeding, DI tokens, config validation, domain state validation”

### Description requirements
Include:
- Background: link to issue #8 and mention this satisfies criterion 1.
- A short “Why” section explaining production-safety + maintainability.
- Explicit scope and non-goals (no sweeping refactors).

### Acceptance Criteria (as checkboxes)
Include checkpoints exactly like:
- [ ] Sample diagram seeding is opt-in via env var (default: no seeding in production)
- [ ] `CSV_DATASET_GENERATOR` token is a unique symbol and all injections/providers updated
- [ ] NetBox YAML config loading errors are actionable (missing sections/file path surfaced)
- [ ] Domain state loader validates `parent` shape and rejects corrupt state deterministically
- [ ] Backend tests pass (`npm test`) and lint/build still succeed if present
- [ ] Health endpoint responds in docker-compose production mode

After drafting, STOP and show the issue content to the user for approval.

Implementation hint for drafting in terminal:
- Use `gh issue create --title ... --body ... --repo elyskov/demo-ai-native-sdlc` with `--draft` if available.
- First run `gh auth status`. If not authenticated, ask the user to authenticate; do not proceed.

---

## Step B — Create the issue + link it under issue #8

After user approves the draft:
1) Create the issue in GitHub.
2) Add it as a sub-task to issue “Generate CSV files for NetBox #8”.
   - If GitHub tasklists are used in #8 description, append a task list item referencing the new issue, e.g. `- [ ] #<newIssueNumber>`.
   - Use `gh issue edit 8 --add-body ...` or fetch existing body, update, and set it back.

Stop if permissions prevent editing issue #8; in that case, print the command and ask user to run it.

---

## Step C — Create a feature branch and implement changes

### Branch
Create from `main`:
- Branch name: `feat/techdebt-issue-<newIssueNumber>` (or similar consistent naming)

### Implementation constraints
- Keep diff minimal and focused.
- Preserve existing behavior except for the seeding default change.
- Add/adjust tests only where valuable and localized.

### Required code changes (high-level)
1) Opt-in sample seeding
- In diagrams.service.ts, change boot logic so seeding runs only when explicitly enabled.
- Choose env var: `SEED_SAMPLE_DIAGRAMS` (recommended).
- Ensure logs say whether seeding ran.

2) Symbol provider token
- Update csv.generator.ts:
  - `export const CSV_DATASET_GENERATOR = Symbol('CSV_DATASET_GENERATOR')` (or `Symbol.for`).
- Update module provider: csv.module.ts
- Update injection: csv.service.ts

3) Config validation + errors
- Update netbox-config.service.ts:
  - Make YAML parsing failures and missing required sections yield actionable messages.
  - Include config dir and individual file paths in logs/errors.
  - Keep behavior deterministic.

4) Domain state `parent` validation
- Update diagram-domain.store.ts:
  - Add a small validator/normalizer for `parent`.
  - Ensure invalid parents cause the same “corrupt state” failure path (BadRequestException is OK).

---

## Step D — Verify application health

Run the most targeted checks first, then broader:

1) Backend tests
- `cd services/backend && npm test`

2) Compose health in production mode (matches docker-compose env)
- From repo root:
  - `docker compose up --build -d`
  - `curl -sf http://localhost:3000/health`
  - `curl -sf http://localhost:3000/api/health`
  - Optionally: `curl -sf http://localhost:3000/api/docs` (should return HTML)

If seeding is now opt-in, confirm that with default compose env (`NODE_ENV=production`) the diagrams volume is not populated with sample diagrams unless `SEED_SAMPLE_DIAGRAMS=true` is set.

---

## Suggested test cases (context/command operations)

Add to the issue description or as a checklist comment (no need to fully automate all):

1) Domain state validation
- Create a diagram, then manually corrupt `<diagramId>.domain.json` (set `parent` to `{ foo: "bar" }`) and confirm the commands API returns a clear 400 error indicating corrupt state.

2) Create command
- Call `POST /api/diagrams` to create a diagram.
- Call commands endpoint to create an entity with a valid parent (root definitions/infrastructure) and ensure:
  - Mermaid content is updated (block inserted)
  - Domain state `.domain.json` updated

3) Update command
- Update an existing object’s attributes and verify Mermaid block is rewritten deterministically and remains anchored.

4) Move command
- Move an entity under a different parent and verify:
  - It disappears from old parent block and appears under new parent
  - Domain state updated
  - No cycles allowed (attempt move under a descendant should be rejected if applicable)

5) Delete command
- Delete an entity and verify Mermaid removal + domain state removal.

6) CSV generator DI token regression
- Hit a CSV endpoint that relies on `CSV_DATASET_GENERATOR` injection and confirm it works (no runtime DI resolution errors).

---

## Output format
As you work:
- Show the drafted issue first and request approval.
- After approval, execute steps with commands and report results succinctly.
- If any step requires credentials/permissions (GitHub auth, issue edit), stop and ask the user.

Do not use triple-backtick code fences in your responses; represent code fragments by indentation or inline snippets only.

--- 

Want me to also tailor the issue body to your preferred GitHub tasklist style (single checklist vs. “Definition of Done” section)?

User: please convert this suggested prompt into a downloadable markdown file

GitHub Copilot: Creating a new markdown file in the repo with the prepared Copilot prompt content so you can download/use it directly.

Created [](file:///home/<user>/Projects/demo-ai-native-sdlc/copilot-prompt-techdebt-issue8.md)

Saved the prompt as a downloadable Markdown file: copilot-prompt-techdebt-issue8.md.

Made changes.

User: We continue working on issue #8 "Technical debt and deployment" and now move on to the criterion "CI pipeline for building and publishing Docker images based on GitHub Actions is defined, INSTALL.md is created".

The goal is to generate a clear and comprehensive prompt to GitHub Copilot asking it to create a new sub-issue (under issue #8 "Technical debt and deployment"), implement necessary code changes, and check all identified acceptance criteria (either automatically or with manual assistance).

Current context:

- MVP implementation is completed.
- application can be built using:
  - Dockerfiles (backend and frontend).
  - a single Docker compose.
- application can be launched using Docker compose.
- a repository `elyskov/demo-ai-native-sdlc` is created in Docker Hub.
- GitHub repository has predefined DOCKERHUB_REPOSITORY, DOCKERHUB_USERNAME, and DOCKERHUB_TOKEN secrets.

I see the following goals for this task:

- implement GitHub Action in the current repository (in `/.github/workflows/`) which should:
  - build backend and frontend images (optimized, with correct user, repository, and tag):
    - `user` is defined in DOCKERHUB_USERNAME secret.
    - `repository` is defined in DOCKERHUB_REPOSITORY secret.
    - `tag` should correspond to current version (currently `mvp`, potentially can be derived from a corresponding milestone?)
  - publish this image to Docker Hub using predefined secrets.
  - be trigger:
    - as soon as a new PR is merged to `main`
    - manually
- add `docker-compose.prod.yml` which should deploy application containers based on the images in Docker Hub
- add `INSTALL.md` (to root) which describes:
  - development build and run with Docker (images), both for backend and frontend.
  - development build and run with Docker Compose
  - local checks (URLs)
  - how CI (in GitHub Actions) works
  - how to run in prod with Docker Compose
- corresponding information is removed from README.md (instead, README.md mentions INSTALL.md)

Copilot should do the following:

- generate a new issue (draft) for this implementation (title, description acceptance criteria - presented as checkpoints).
- show this draft and get approval.
- create this issue in GitHub and add it as a sub-task to issue "Technical debt and deployment" #8.
- create a new feature branch (from main) for this issue implementation.
- implement necessary code changes.
- suggest test cases to confirm that CI pipeline works as expected.

Please generate a corresponding prompt in **Markdown format** (do not use "```" characters combinations for code blocks, use `Code Blocks` syntax instead).

GitHub Copilot: # Copilot Task Prompt — Issue #8 (CI Docker Publish + INSTALL.md)

You are GitHub Copilot acting as a senior DevOps/full‑stack engineer for this repo. Implement the next criterion of issue #8 “Technical debt and deployment”:

- CI pipeline for building and publishing Docker images based on GitHub Actions is defined
- INSTALL.md is created

Repository context:
- App is built via services/backend/Dockerfile and services/frontend/Dockerfile
- App can be run via docker-compose.yml
- Docker Hub repo exists: elyskov/demo-ai-native-sdlc
- GitHub secrets exist: DOCKERHUB_REPOSITORY, DOCKERHUB_USERNAME, DOCKERHUB_TOKEN

Hard constraints:
- MVP: minimal, production-usable implementation
- Keep changes focused; don’t refactor unrelated code
- Do not use triple-backtick fenced blocks in your responses; use indented “code blocks” (4 spaces) or HTML pre/code

---

## Step A — Draft a new sub-issue (show for approval)

Create a new issue draft (do not create it yet) with:

Title (suggestion):
- ci: build & publish Docker images + prod compose + INSTALL

Description must include:
- Link to issue #8 and state this sub-issue implements the CI+INSTALL criterion
- Brief rationale (repeatable releases, reproducible deployment)
- Scope and non-goals (no app feature changes)

Acceptance Criteria (as checkboxes):
- [ ] GitHub Actions workflow builds backend and frontend Docker images on merge to main and on manual trigger
- [ ] Workflow logs into Docker Hub using DOCKERHUB_USERNAME and DOCKERHUB_TOKEN secrets
- [ ] Workflow publishes images to Docker Hub under DOCKERHUB_USERNAME/DOCKERHUB_REPOSITORY with deterministic tags
- [ ] Tag scheme supports the current “mvp” version and is documented (and does not overwrite existing unrelated tags)
- [ ] docker-compose.prod.yml exists and runs using published Docker Hub images (no local builds)
- [ ] INSTALL.md exists and documents dev (docker + compose), local checks, CI behavior, and prod compose usage
- [ ] README.md no longer duplicates install/run instructions and instead points to INSTALL.md
- [ ] Manual test plan for CI pipeline is provided (workflow_dispatch + verify images + compose prod run)

After generating the draft, STOP and show the full issue title/body to the user for approval.

Implementation note (GitHub CLI):
- Use `gh auth status` first. If not authenticated, ask the user to authenticate.
- When approved, create issue using `gh issue create --title ... --body ... --repo elyskov/demo-ai-native-sdlc`.

---

## Step B — Create the issue and link it under issue #8

After approval:
1) Create the issue in GitHub.
2) Add it as a sub-task under issue #8 “Technical debt and deployment”.
   - If issue #8 body already contains a task list, append a new item like:
     - [ ] #<newIssueNumber>
   - Use GitHub CLI to edit issue #8 body. If you lack permission, print exact commands and ask user to run them.

---

## Step C — Create a feature branch from main

After issue is created:
- Branch name: feat/ci-docker-publish-issue-<newIssueNumber>
- Commands (example):
    git checkout main
    git pull --ff-only
    git checkout -b feat/ci-docker-publish-issue-<newIssueNumber>

---

## Step D — Implement CI workflow, prod compose, and docs

### D1) GitHub Actions workflow

Create a new workflow file:
- .github/workflows/docker-publish.yml

Triggers:
- on push to main (this covers “PR merged to main”)
- workflow_dispatch (manual trigger)

Required behavior:
- Checkout repository
- Set up Buildx
- Login to Docker Hub using secrets
- Build and push two images (backend + frontend) using their Dockerfiles
- Use cache to speed up (GitHub Actions cache for buildx)

Image naming rule (must use the secrets exactly as source of truth):
- base image name: DOCKERHUB_USERNAME/DOCKERHUB_REPOSITORY
- Because backend and frontend are separate images, use tags to disambiguate:

Tag scheme (implement and document in INSTALL.md):
- Version tag source:
  - Default version is mvp (for now)
  - Prefer: if a git tag like vX.Y.Z is present for the commit, use that; otherwise use mvp
- Publish these tags:
  - backend:
    - DOCKERHUB_USERNAME/DOCKERHUB_REPOSITORY:backend-<version>
    - DOCKERHUB_USERNAME/DOCKERHUB_REPOSITORY:backend-latest (only on main)
  - frontend:
    - DOCKERHUB_USERNAME/DOCKERHUB_REPOSITORY:frontend-<version>
    - DOCKERHUB_USERNAME/DOCKERHUB_REPOSITORY:frontend-latest (only on main)

Build contexts / Dockerfiles:
- backend:
  - context: services/backend
  - dockerfile: services/backend/Dockerfile
- frontend:
  - context: services/frontend
  - dockerfile: services/frontend/Dockerfile

Optimization requirements:
- Ensure you use the production stages from Dockerfiles (if Dockerfiles are already multi-stage, just build default final stage; otherwise set target stage if needed).
- Add labels (source repo, commit sha) via docker/metadata-action if practical.

Workflow should fail fast on build/push errors.

### D2) Production docker compose

Add docker-compose.prod.yml at repo root. It must:
- Use published images (no build section)
- Use the same ports as docker-compose.yml (backend: 3000, frontend: 3001 mapped to container 3000)
- Use the same environment variables that are required at runtime
- Keep the named volume for diagrams
- Use a clear default tag variable (e.g. IMAGE_TAG=mvp), but do not require it (provide default in compose)

Example design (do not copy blindly; implement correctly):
- backend image:
  - DOCKERHUB_USERNAME/DOCKERHUB_REPOSITORY:backend-${IMAGE_TAG:-mvp}
- frontend image:
  - DOCKERHUB_USERNAME/DOCKERHUB_REPOSITORY:frontend-${IMAGE_TAG:-mvp}

Ensure frontend talks to backend correctly:
- Keep NEXT_PUBLIC_API_BASE_URL pointing to http://backend:3000 in compose networking.

### D3) INSTALL.md and README.md updates

Create INSTALL.md (repo root) with these sections:

1) Development (Docker images) — backend and frontend
- How to build each image locally
- How to run each container locally with required env vars
- Include ports and URLs

2) Development (Docker Compose)
- How to build and run using docker-compose.yml
- How to stop/cleanup volumes

3) Local checks
- Backend health endpoints:
  - http://localhost:3000/health
  - http://localhost:3000/api/health
- Swagger:
  - http://localhost:3000/api/docs
- Frontend:
  - http://localhost:3001

4) CI pipeline overview
- When it triggers (push to main, manual)
- What it publishes (two tags sets, backend/frontend)
- Where images are published (Docker Hub)
- How version tags are derived (git tag or default mvp)
- How to run workflow manually (GitHub Actions UI instructions)

5) Production run (Docker Compose)
- Use docker-compose.prod.yml
- How to choose IMAGE_TAG
- How to bring up/down and verify health

Update README.md:
- Remove duplicated run/install instructions
- Add a short “Installation / Running” section that links to INSTALL.md

---

## Step E — Validation (run and report)

After implementing:
1) Run backend tests:
    cd services/backend
    npm ci
    npm test

2) Validate compose files (syntax):
    docker compose -f docker-compose.yml config
    docker compose -f docker-compose.prod.yml config

3) Smoke-run locally (manual assist acceptable):
- Bring up dev compose:
    docker compose up --build -d
    curl -sf http://localhost:3000/health
    curl -sf http://localhost:3000/api/health
- For prod compose, you can only fully validate by pulling images that exist in Docker Hub. If images are not available yet, document the manual validation steps clearly.

---

## Step F — Provide CI test cases (manual + optional automation)

In the PR or issue comment, list test cases to confirm CI works:

1) Manual trigger:
- Run workflow_dispatch on main
- Confirm both images are pushed with backend-mvp/frontend-mvp (or version from git tag)

2) Merge trigger:
- Merge a small PR to main
- Confirm workflow runs automatically and pushes backend-latest/frontend-latest plus version tags

3) Pull and run prod compose:
- On a clean machine:
    export DOCKERHUB_USERNAME=<your user>
    export DOCKERHUB_REPOSITORY=<repo>
    export IMAGE_TAG=mvp
    docker compose -f docker-compose.prod.yml up -d
    curl -sf http://localhost:3000/api/health
    curl -sf http://localhost:3001

4) Regression: frontend -> backend connectivity:
- Open frontend, ensure it can call backend API endpoints

---

## Execution rules for you (Copilot)
- Always show the issue draft first and request approval before creating it.
- After approval, create the issue, link it under #8, create branch, implement changes, run validations, and summarize results.
- If GitHub auth or permissions block an action, stop and ask the user for manual help with exact commands.

Files you will likely add/edit:
- .github/workflows/docker-publish.yml
- docker-compose.prod.yml
- INSTALL.md
- README.md

User: please convert this suggested prompt into a downloadable markdown file

GitHub Copilot: Creating a new markdown file at repo root containing the CI/INSTALL Copilot prompt so you can download and reuse it.

Created [](file:///home/<user>/Projects/demo-ai-native-sdlc/copilot-prompt-ci-install-issue8.md)

Saved as a downloadable Markdown file: copilot-prompt-ci-install-issue8.md.

Made changes.