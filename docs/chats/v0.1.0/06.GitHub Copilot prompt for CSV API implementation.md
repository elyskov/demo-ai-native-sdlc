User: Act as an experienced prompt engineer in software development and help prepare a prompt for GitHub Copilot in the context of the current project.

This prompt should give the Copilot a clear task to implement the first criterion ("Backend CSV API calculates and return an ordered list of types of elements for a given diagram") from the task #7 "Generate CSV files for NetBox".

Current context:
- UX/UI is implemented.
- NetBox diagrams are stored in file system.
- CSV export mock implementation backend supports sample exporting.

I see the following goals for this task:
- rework `/api/csv/:diagramId` API command so that:
  - it takes an additional parameter (category) and returns types only for that category (see below)
  - a list of typesis is ordered based on analysis of NetBox model configuration (see below)
- NetBox model configuration analysis can be performed at the application startup (once), since NetBox model configuration is static.
- this analysis should be based on the following rules:
  - types are grouped into categories based on root elements (Definitions, Infrastructure).
  - in each group, a graph of entity dependencies should be built according to the `links` section
  - each graph should be converted into an ordered list using the **topological sort** operation, i.e. from less dependent to more dependent elements types.

Copilot should do the following:
- generate a new issue (draft) for this implementation (title, description acceptance criteria).
- show this draft and get approval.
- create this issue in GitHub and add it as a sub-task to issue #7.
- create a new feature branch (from main) for this issue implementation.
- implement necessary code changes.
- check application health.
- suggest test cases to confirm that context operations work as expected.

Important points:
- launching the application for testing should be through docker.
- acceptance criteria should be presented as checkpoints.

Please generate a corresponding prompt in Markdown format.

GitHub Copilot: ```markdown
# Copilot Task Prompt — Issue + Implementation (Task #7 / Criterion 1)

You are GitHub Copilot in agent mode working in this repo (Next.js frontend + Nest.js backend + Docker). Implement **Task #7 “Generate CSV files for NetBox” — Criterion 1**:

> **Backend CSV API calculates and returns an ordered list of types of elements for a given diagram.**

## Context (what already exists)
- UX/UI is implemented.
- NetBox diagrams are stored on the filesystem (backend already reads diagrams by `diagramId`).
- Backend has a mock CSV export implementation.
- NetBox model configuration is static and lives in YAML (see [services/backend/config/netbox-model.yaml](services/backend/config/netbox-model.yaml)).
- Current CSV API code is in:
  - [services/backend/src/csv/csv.controller.ts](services/backend/src/csv/csv.controller.ts)
  - [services/backend/src/csv/csv.service.ts](services/backend/src/csv/csv.service.ts)
  - [services/backend/src/csv/csv.generator.ts](services/backend/src/csv/csv.generator.ts)
  - (mock) [services/backend/src/csv/mock-csv.generator.ts](services/backend/src/csv/mock-csv.generator.ts)

## High-level goals
Rework the `GET /api/csv/:diagramId` API so that:
1. It accepts an additional parameter `category`.
2. It returns **types only** for that category.
3. The returned types list is **ordered deterministically** based on a dependency analysis of the NetBox model configuration:
   - Types are grouped into categories based on root elements (at minimum: `Definitions`, `Infrastructure`).
   - For each category, build a directed dependency graph of entity types using the model config `links` section.
   - Convert the graph into an ordered list via **topological sort** (from less dependent → more dependent types).
4. Perform the model configuration analysis **once at application startup** (static config).

Important: the app must still be runnable/testable via **Docker**.

---

# Part 1 — Create a new Issue (draft first)

## 1) Draft Issue (show for approval)
Generate a **draft** GitHub Issue with:
- **Title**
- **Description** (what/why)
- **Acceptance criteria** formatted as checkpoints (GitHub markdown checklist)
- **Implementation notes** (brief, actionable)
- **Test plan** (brief)

Include explicit scope boundaries:
- This criterion returns ordered **types** only (not the full CSV export).
- Model analysis is computed once at startup and cached.

Stop and present the draft for approval.

## 2) After approval
- Create the issue in GitHub.
- Add it as a sub-task to Issue **#7** (link it and/or add a checklist item in #7, depending on repo conventions and permissions).

If you do not have GitHub permissions from this environment, output:
- The exact issue body markdown to paste
- The exact GitHub CLI commands (`gh`) you would run (do not run them unless explicitly allowed)

---

# Part 2 — Implementation (feature branch + code changes)

## 3) Create a feature branch
From `main`, create a branch named like:
- `feat/netbox-csv-types-ordering`
or include the issue number if known.

## 4) API behavior (contract)
Update the CSV API to support a **category** parameter and return **ordered types** for that category and diagram.

### Parameter format
Prefer `category` as a query parameter:
- `GET /api/csv/:diagramId?category=Definitions`
- `GET /api/csv/:diagramId?category=Infrastructure`

(If the current endpoint must remain for mock CSV export, keep backwards compatibility by:
- Returning types **only when** `category` is provided, otherwise preserve the existing mock export behavior.
- Or introduce a dedicated route `GET /api/csv/:diagramId/types?category=...` and keep the original export route unchanged.
Choose the smallest change that does not break existing UI behavior.)

### Response format
Return JSON:
```json
{
  "diagramId": "…",
  "category": "Definitions",
  "types": ["site", "region", "tenant"]
}
```

### Error handling
- Invalid `category` → `400` with a helpful message and list of allowed categories.
- Unknown `diagramId` → `404`.
- If model config contains cycles in dependencies → fail fast at startup with a clear error (preferred), or return `500` with a diagnostic log (only if fail-fast is not feasible).

---

# Part 3 — Model analysis at startup (NetBox model config)

## 5) Build a startup analysis service
Implement a provider/service that:
- Loads and parses [services/backend/config/netbox-model.yaml](services/backend/config/netbox-model.yaml) once.
- Produces, for each category, a cached ordered list of types using:
  1) category grouping by root elements (`Definitions`, `Infrastructure`)
  2) dependency graph edges derived from `links`
  3) topological sort producing deterministic order

Implementation requirements:
- Deterministic output: when multiple valid topo orders exist, enforce a stable tie-breaker (e.g., lexicographic by type name).
- Keep the analysis in memory for fast API responses.
- Log a short summary at startup (categories found, counts).

## 6) Diagram-aware filtering
The API must return types relevant to the given `diagramId`:
- Extract which NetBox entity types are present/needed for that diagram.
- Then **filter** the precomputed category ordering to only those types (preserving order).

If the diagram format is Mermaid/C4-ish:
- Use existing backend parsing/mapping utilities already in the repo rather than inventing a new parser.
- If only a subset is possible for this criterion, document what “types present in a diagram” means and implement it consistently.

---

# Part 4 — Validation (Docker-only)

## 7) Run and check health via Docker
Use Docker for testing:
- `docker compose up --build`

Verify backend health endpoint (see [services/backend/src/health](services/backend/src/health)):
- `curl http://localhost:<backend-port>/api/health` (use the port from `docker-compose.yml`)

Then verify the updated CSV endpoint with at least:
- a valid `diagramId` + `category=Definitions`
- a valid `diagramId` + `category=Infrastructure`
- invalid category
- unknown diagramId

---

# Part 5 — Tests + suggested test cases

## 8) Add/adjust tests where reasonable
Add unit tests for:
- Dependency graph building from model config
- Topological sort ordering (including deterministic tie-breaking)
- Cycle detection behavior
- Filtering ordering by “types present in diagram”

If the repo has no test framework set up for backend, keep tests minimal and aligned with existing tooling (do not introduce heavy new frameworks without need). If adding tests is not feasible, provide a clear manual test plan.

## 9) Suggest manual test cases (must include)
At minimum, list manual test cases that confirm:
- Ordering matches dependency rules
- Same input → same output (deterministic)
- Category filtering works
- Diagram filtering works
- Proper HTTP errors for invalid inputs

---

# Deliverables checklist (what you must produce)
1. Draft issue text (title/description/checkpoints) → ask for approval.
2. After approval: issue created and linked as sub-task to #7 (or provide `gh` commands if you can’t create it).
3. Feature branch created.
4. Backend implementation merged into the branch:
   - startup model analysis + topo sort
   - updated API behavior for category → ordered types
5. Docker health check + endpoint checks executed (show commands + results).
6. Test cases (automated and/or manual) documented succinctly.

Be MVP-focused: do not implement full CSV generation in this criterion unless required to keep existing behavior from breaking.
```

User: We continue working on issue #7 "Generate CSV files for NetBox" and now move on to the criterion "Backend CSV generator follows NetBox CSV schema for chosen object types".

The goal is to generate a clear and comprehensive prompt to GitHub Copilot asking it to create a new sub-issue (under issue #7 "Generate CSV files for NetBox"), implement necessary code changes, and check all identified acceptance criteria (either automatically or with manual assistance).

Current context:

- NetBox diagrams are stored in file system.
- CSV export mock implementation backend supports sample exporting.
- NetBox model configuration analysis is implemented and correct list of types for a given diagram can be received on backend.

I see the following goals for this task:

- ensure that csv generator supports generating both a full set of CSV files for a given diagram, and, if requested, a single CSV file for a particular type.
- replace `mock-csv.generator` with a full-fledged real generator.
- CSV format for any entity type should be based on NetBox model configuration (section `attributes`), using comma as a separator.
- CSV data set should be ordered, based on NetBox model configuration analysis (first definitions types, then infrastructure types).
- CSV file names should start from a corresponding number of this order.

Copilot should do the following:

- generate a new issue (draft) for this implementation (title, description acceptance criteria).
- show this draft and get approval.
- create this issue in GitHub and add it as a sub-task to issue "Generate CSV files for NetBox" #7.
- create a new feature branch (from main) for this issue implementation.
- implement necessary code changes.
- check application health.
- suggest test cases to confirm that context operations work as expected.

Important points:

- existing docker-compose should be used to launch the application for testing
- acceptance criteria should be presented as checkpoints

Please generate a corresponding prompt in Markdown format. Pay attention on correct escaping when needed.

GitHub Copilot: ```markdown
# Copilot Task Prompt — Issue + Implementation (Task #7 / Criterion: CSV schema-compliant generator)

You are GitHub Copilot in agent mode working in this repo (Next.js frontend + Nest.js backend + Docker). Implement the next criterion under Issue **#7 “Generate CSV files for NetBox”**:

> **Backend CSV generator follows NetBox CSV schema for chosen object types.**

This work must create a new sub-issue (draft first), then implement it on a feature branch, validate via Docker, and confirm acceptance criteria (automated tests if feasible; otherwise a clear manual test plan).

## Current context (already implemented / available)
- Diagrams are stored on the filesystem and can be retrieved by `diagramId`.
- Backend has a mock CSV export implementation.
- NetBox model configuration analysis is implemented: backend can compute the correct ordered list of types for a given diagram, with ordering derived from config dependency rules (Definitions first, then Infrastructure).
- NetBox model configuration exists in YAML (see [services/backend/config/netbox-model.yaml](services/backend/config/netbox-model.yaml)).

Relevant backend locations (inspect these first; do not guess):
- CSV module:  
  - [services/backend/src/csv/csv.controller.ts](services/backend/src/csv/csv.controller.ts)  
  - [services/backend/src/csv/csv.service.ts](services/backend/src/csv/csv.service.ts)  
  - [services/backend/src/csv/csv.generator.ts](services/backend/src/csv/csv.generator.ts)  
  - mock generator: [services/backend/src/csv/mock-csv.generator.ts](services/backend/src/csv/mock-csv.generator.ts)
- NetBox config/services: [services/backend/src/netbox-config](services/backend/src/netbox-config)

---

# Part 1 — Create a new Issue (draft first)

## 1) Draft Issue (show for approval)
Generate a **draft** GitHub Issue with:
- **Title**
- **Description** (what/why; mention this is a subtask of #7)
- **Acceptance criteria** as checkpoints (GitHub markdown checklist)
- **Implementation notes** (brief, actionable)
- **Test plan** (brief)

Stop and present the draft for approval before creating anything in GitHub.

## 2) After approval
- Create the issue in GitHub.
- Add it as a sub-task to Issue **#7** (link it and/or add a checklist item to #7).

If you cannot create issues from this environment (no auth), output:
- The exact issue body markdown to paste
- The exact `gh` CLI commands you would run (do not run them unless explicitly allowed)

---

# Part 2 — Required behavior & scope

## 3) Generator must support:
1. **Full export**: generate a **set of CSV files** for a given diagram (one CSV per type present/needed).
2. **Single-type export**: if requested, generate **only one CSV file** for a particular `type`.

Important: This criterion is about **schema-compliant CSV output** for chosen types, not UI changes.

## 4) Replace mock generator
- Replace usage of `mock-csv.generator` with a real generator.
- Keep the public API stable where possible (avoid breaking UI), but correctness over mocks is required now.
- If backwards compatibility is needed, keep a feature flag or fallback only if strictly necessary; default must be the real generator.

## 5) CSV schema rules (from NetBox model config)
For any entity `type`:
- Column headers must be derived from NetBox model config for that `type`, using the `attributes` section.
- Separator: comma `,`
- Output must be deterministic (stable column ordering and stable row ordering).

Implementation specifics:
- The order of columns must match the order defined in config (do not sort alphabetically unless config is unordered; prefer “as defined in YAML”).
- Values:
  - Convert `null`/`undefined` to empty field.
  - Escape fields per CSV rules: quote with `"` when needed and escape `"` as `""`.
  - Ensure line endings are consistent (`\n` is fine).
- Include the header row always.

## 6) Dataset ordering across types
- The **set** of CSV files must be ordered according to the already-implemented “types order for a diagram” analysis:
  1) all `Definitions` types (in their topo order)
  2) then all `Infrastructure` types (in their topo order)
- File names must start with an order number based on this global order.

### File naming format (define & implement)
Implement file naming like:
- `01__<type>.csv`
- `02__<type>.csv`
… (zero-padded; choose padding width that supports at least 99 types, e.g. 2 digits; if there can be more, use 3 digits)

Make it deterministic and documented in code and/or README.

---

# Part 3 — API design (keep existing docker-compose workflow)

## 7) Backend API endpoints
Update/extend the backend CSV API to support both modes:

- Full export:
  - `GET /api/csv/:diagramId/export`
  - returns a zip OR a JSON payload with files (choose one based on current patterns; prefer the smallest change and alignment with existing UI)
- Single-type export:
  - `GET /api/csv/:diagramId/export?type=<typeName>`
  - returns a single CSV file

If the project already has an established route contract for CSV export, keep it and extend via query params:
- Example: `GET /api/csv/:diagramId?type=<typeName>`  
Use what exists; do not invent a new contract unless necessary.

Response requirements:
- Must include correct content type(s):
  - For single CSV: `text/csv; charset=utf-8`
  - For zip: `application/zip`
- Set `Content-Disposition` with a safe filename.

Error handling:
- Unknown `diagramId` → `404`
- Unknown `type` or type not in the diagram’s computed types list → `400` (include allowed types list)
- If config missing attributes for a requested type → `500` (log clearly) or `400` if it’s an invalid request; pick one and be consistent.

---

# Part 4 — Data mapping (MVP, but real)
You must generate actual rows for each CSV. Use the diagram content + existing mapping services.

Constraints:
- Prefer existing domain/store or mapping logic already present in the backend (do not write a new bespoke parser unless unavoidable).
- If some attributes cannot be populated from current diagram data:
  - Still include the column.
  - Output empty value for that attribute.
  - Document the limitation in the issue and in code (short comment) and keep behavior deterministic.

Row ordering:
- Must be deterministic.
- If entities have names/IDs, sort by that stable key.
- Do not rely on filesystem enumeration order.

---

# Part 5 — Branch + Implementation steps

## 8) Create a feature branch
From `main`, create a branch named like:
- `feat/netbox-csv-schema-generator`
(or include the new issue number once created)

## 9) Implement code changes (backend)
Minimum expected refactors:
- Replace mock generator with real generator.
- Ensure generator can output:
  - a single CSV by type
  - a set of CSVs for the diagram ordered by model-derived type order
- Add/adjust DTOs and controller logic to accept optional `type`.

Keep changes MVP-focused and consistent with existing Nest.js structure.

---

# Part 6 — Validation via Docker Compose

## 10) Run & verify with Docker Compose only
Use existing `docker-compose.yml`:
- `docker compose up --build`

Verify backend health endpoint:
- `curl http://localhost:<backend-port>/api/health` (use the port from compose)

Verify CSV export endpoints:
- Full export returns all expected files ordered and numbered.
- Single-type export returns exactly one CSV with correct header columns.

---

# Part 7 — Acceptance criteria (must be checkpoints in issue AND verified)

Your issue acceptance criteria must include checkpoints covering:

- [ ] Full export generates a deterministic ordered set of CSV files for a diagram
- [ ] Single-type export generates exactly one CSV for the requested type
- [ ] CSV header columns are derived from `netbox-model.yaml` `attributes` for the type (ordered as defined)
- [ ] CSV uses comma separator and correct escaping for quotes/commas/newlines
- [ ] Dataset/file ordering follows model-derived type ordering (Definitions first, then Infrastructure)
- [ ] Filenames are numbered with the order prefix (e.g., `01__type.csv`)
- [ ] Invalid `diagramId` returns `404`
- [ ] Invalid `type` returns `400` with allowed types
- [ ] Docker Compose run passes health check
- [ ] Manual test plan (or automated tests) confirms correctness

---

# Part 8 — Tests and manual verification

## 11) Automated tests (preferred)
Add unit tests if the backend already has a test setup:
- CSV escaping rules
- Header generation from config `attributes`
- Deterministic ordering (types and rows)
- Single-type vs full export behavior

If adding tests is not feasible, provide a precise manual test plan.

## 12) Suggest manual test cases (must output)
At minimum provide test cases:
- Export full set for a known diagramId, verify filenames `01__...` sequence and type order matches backend types-order endpoint.
- Export one type, verify header matches config `attributes`.
- Fields with commas/quotes/newlines are escaped properly (create or use a diagram element name containing `,` and `"`).
- Invalid type and invalid diagramId return correct errors.

---

# Deliverables checklist (what you must produce)
1. Draft issue text (title/description/checkpoints) → ask for approval.
2. After approval: issue created and linked as sub-task to #7 (or provide `gh` commands if you can’t create it).
3. Feature branch created.
4. Backend implementation on that branch:
   - real CSV generator (no mock)
   - single-type + full-export support
   - config-driven headers and deterministic ordering + numbered filenames
5. Docker Compose health check and endpoint verification executed (show commands and outputs).
6. Tests added or manual test plan provided.

Be careful with escaping when generating CSV:
- Quote fields when they contain `","`, `"\""`, `"\n"`, or `"\r"`.
- Escape `"` inside quoted fields by doubling it (`""`).
```


User: We continue working on issue #7 "Generate CSV files for NetBox" and now move on to the criterion "Diagram List ⋮ menu is extended with items to download CSV exports".

The goal is to generate a clear and comprehensive prompt to GitHub Copilot asking it to create a new sub-issue (under issue #7 "Generate CSV files for NetBox"), implement necessary code changes, and check all identified acceptance criteria (either automatically or with manual assistance).

Current context:

- CSV export API is implemented and ready to be used on UI.
- UI is fully implemented and already has necessary enrty point (`⋮` menu).

I see the following goals for this task:

- extend "⋮" menu in Diagrams List with new item "Download", which opens a submenu with the following items:
  - "All CSV files zipped" (or similar). clicking this item should download ZIP-archive with the whole CSV dataset (using `/api/csv/:diagramId/zip` API command).
  - Definitions, which opens a submenu with a list of types (dynamically calculated for the current diagram) for a definitions part of the diagram. clicking on a submenu item (one of definitions types for the diagram) should download a single CSV file for all elements of a selected type (using `/api/csv/:diagramId?type=<entity>` API command).
  - Infrastructure, which opens a submenu with a list of types (dynamically calculated for the current diagram) for a infrastructure part of the diagram. clicking on a submenu item (one of infrastructure types for the diagram) should download a single CSV file for all elements of a selected type (using `/api/csv/:diagramId?type=<entity>` API command).

Copilot should do the following:

- generate a new issue (draft) for this implementation (title, description acceptance criteria).
- show this draft and get approval.
- create this issue in GitHub and add it as a sub-task to issue "Generate CSV files for NetBox" #7.
- create a new feature branch (from main) for this issue implementation.
- implement necessary code changes.
- check application health.
- suggest test cases to confirm that context operations work as expected.

Important points:

- existing docker-compose should be used to launch the application for testing
- acceptance criteria should be presented as checkpoints

Please generate a corresponding prompt in Markdown format (pay attention on correct escaping).

GitHub Copilot: ```markdown
# Copilot Task Prompt — UI: Diagram List ⋮ menu CSV downloads (Issue #7 sub-task)

You are GitHub Copilot in agent mode working in this repo (Next.js App Router frontend + Nest.js backend + Docker). Implement the next criterion under Issue **#7 “Generate CSV files for NetBox”**:

> **Diagram List ⋮ menu is extended with items to download CSV exports.**

This work must create a new sub-issue (draft first), then implement it on a feature branch, validate via Docker Compose, and confirm acceptance criteria (automated checks if feasible; otherwise provide a precise manual test plan).

## Current context (already available)
- CSV export API is implemented and ready to be used by UI:
  - Download ZIP for full dataset: `GET /api/csv/:diagramId/zip`
  - Download a single CSV by type: `GET /api/csv/:diagramId?type=<entity>`
- UI is implemented and has an entry point: the Diagram List `⋮` menu.
- Backend can dynamically calculate ordered types for a diagram (Definitions vs Infrastructure) and expose them (use the existing endpoint used previously; inspect repo and reuse it).

Frontend files to inspect first (do not guess):
- Diagram list UI: [services/frontend/app/diagrams-list.tsx](services/frontend/app/diagrams-list.tsx)
- Backend client helpers: [services/frontend/lib/backend.ts](services/frontend/lib/backend.ts)
- Existing UI primitives for menus: [services/frontend/components/ui/dropdown-menu.tsx](services/frontend/components/ui/context-menu.tsx)

---

# Part 1 — Create a new Issue (draft first)

## 1) Draft Issue (show for approval)
Generate a **draft** GitHub Issue including:
- **Title**
- **Description** (what/why; mention it is a sub-task of #7)
- **Acceptance criteria** as checkpoints (GitHub markdown checklist)
- **Implementation notes**
- **Test plan** (manual + any automation)

Stop and present the draft for approval before creating anything in GitHub.

## 2) After approval
- Create the issue in GitHub.
- Add it as a sub-task to Issue **#7** (link it and/or add a checklist item to #7).

If you cannot create issues from this environment (no auth), output:
- The exact issue body markdown to paste
- The exact `gh` commands you would run (do not run them unless explicitly allowed)

---

# Part 2 — UX requirements (⋮ menu structure)

## 3) Extend the Diagram List `⋮` menu
Add a top-level item: **“Download”** that opens a submenu with:

1) **“All CSV files (ZIP)”** (label can be “All CSV files zipped” or similar)
- On click: download a ZIP archive of the whole CSV dataset for the diagram using:
  - `GET /api/csv/:diagramId/zip`
- The browser should download a file (do not just open in a new tab unless that’s the current pattern).

2) **“Definitions”** submenu
- Opens a submenu listing **Definitions types** for the current diagram (dynamically computed).
- Clicking a type downloads a single CSV for that type via:
  - `GET /api/csv/:diagramId?type=<entity>`

3) **“Infrastructure”** submenu
- Opens a submenu listing **Infrastructure types** for the current diagram (dynamically computed).
- Clicking a type downloads a single CSV for that type via:
  - `GET /api/csv/:diagramId?type=<entity>`

Notes:
- The type lists must be computed per diagram (not hard-coded).
- Preserve the order from backend analysis (do not sort on the client unless backend is unordered).

---

# Part 3 — Data fetching + download mechanics

## 4) Fetch diagram type lists
Use existing backend API(s) that provide:
- ordered Definitions types for a diagram
- ordered Infrastructure types for a diagram

If there is one endpoint that returns categories, use it.
If it requires a `category` parameter, call it twice (Definitions + Infrastructure).
Reuse existing client infrastructure in [services/frontend/lib/backend.ts](services/frontend/lib/backend.ts).

Caching:
- It’s OK to fetch on-demand when the menu opens.
- If there is an existing caching strategy (SWR/React Query), follow it; otherwise keep it simple (React state + `fetch`).

Loading and failure handling (MVP but real):
- While loading types: show a disabled “Loading…” item (or skeleton-like menu item).
- On error: show “Failed to load types” disabled item and log to console.
- If the list is empty: show “No types found” disabled item.

## 5) Download implementation
Implement downloads in a way that reliably triggers “Save file” behavior:
- Prefer `fetch()` → `Blob` → `URL.createObjectURL()` → synthetic `<a download>` click.
- Ensure you call `URL.revokeObjectURL()` after triggering download.

Filenames:
- For ZIP, use a safe default like `diagram-<diagramId>-csv.zip` unless server already provides `Content-Disposition`.
- For single CSV, use `diagram-<diagramId>-<type>.csv` unless server provides `Content-Disposition`.
- If server sets `Content-Disposition`, honor it when possible (browser will typically do this automatically when using direct navigation; with `fetch` you may need to parse headers—MVP: generate a safe client filename).

Accessibility:
- Menu items must be keyboard-navigable (use existing menu components).
- Ensure submenu triggers have correct aria attributes (the UI component library likely handles this; do not break it).

---

# Part 4 — Branch + Implementation steps

## 6) Create a feature branch
From `main`, create a branch named like:
- `feat/ui-csv-download-menu`
(or include the new issue number once created)

## 7) Implement frontend changes
Expected touchpoints:
- Update Diagram List `⋮` menu component(s) to include Download submenu structure.
- Add backend client function(s) in [services/frontend/lib/backend.ts](services/frontend/lib/backend.ts) to fetch types for a diagram by category.
- Add a small download helper (either colocated or in a shared util) that:
  - downloads ZIP
  - downloads CSV by type

Keep it MVP-focused and consistent with existing patterns.

---

# Part 5 — Validation via Docker Compose

## 8) Run & verify using docker-compose only
Use the existing `docker-compose.yml`:
- `docker compose up --build`

Checks to perform:
- App loads diagrams list.
- Open `⋮` → Download → verify:
  - “All CSV files (ZIP)” triggers a `.zip` download and file is non-empty.
  - “Definitions” submenu loads types, clicking one triggers `.csv` download.
  - “Infrastructure” submenu loads types, clicking one triggers `.csv` download.

---

# Acceptance criteria (must be in issue as checkpoints AND verified)
Include these checkpoints verbatim or equivalent:

- [ ] Diagram List `⋮` menu contains a “Download” submenu
- [ ] “All CSV files (ZIP)” downloads using `GET /api/csv/:diagramId/zip`
- [ ] “Definitions” submenu lists diagram-specific ordered definitions types from backend
- [ ] Clicking a Definitions type downloads a single CSV using `GET /api/csv/:diagramId?type=<entity>`
- [ ] “Infrastructure” submenu lists diagram-specific ordered infrastructure types from backend
- [ ] Clicking an Infrastructure type downloads a single CSV using `GET /api/csv/:diagramId?type=<entity>`
- [ ] Loading/error/empty states are handled gracefully in the menu
- [ ] Works when running via `docker compose up --build`
- [ ] Manual test plan (or automated tests) confirms expected behavior

---

# Tests + suggested manual test cases (must output)
If the frontend has an established test setup, add lightweight tests:
- Menu rendering
- Calls correct endpoints on click
- Download helper called with correct URL

If not, provide a manual test plan including:
1) With backend running, open Diagrams list, open `⋮` → Download, verify types appear under Definitions/Infrastructure.
2) Click “All CSV files (ZIP)”, verify browser downloads a `.zip` and it contains CSVs.
3) Click a Definitions type, verify downloaded `.csv` header looks correct (comma-separated).
4) Try with a diagram that has no Definitions types (or none in Infrastructure), verify “No types found” is shown.
5) Simulate backend error (stop backend container), verify “Failed to load types” appears and UI remains responsive.

---

# Deliverables checklist (what you must produce)
1. Draft issue text → ask for approval.
2. After approval: create issue and link it under #7 (or output `gh` commands if not possible).
3. Feature branch created.
4. Frontend implementation complete (Download submenu + dynamic type lists + downloads).
5. Docker Compose health check (backend `/api/health`) and UI verification steps executed (show commands + results).
6. Test cases (automated if feasible, otherwise manual) documented succinctly.

Be careful with URL construction and escaping:
- When building URLs with `type=<entity>`, use `encodeURIComponent(entity)`.
```